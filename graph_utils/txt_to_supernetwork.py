# This module imports .txt to build a supernetwork

from igraph import *
from graph_utils.txt_to_igraph import edge_dict_to_igraph
import numpy as np

__author__ = "jeromethai"


def txt_to_supernetwork(filepath_net, filepath_act, name, alpha=1.0, shifting=True):
    # Construct supernetwork from *_net_times.txt files
    # and from *_activities.txt file
    edge_dict = txt_to_superedge_dict(filepath_net, alpha)
    edge_activities_dict = txt_to_activities_edge_dict(filepath_act, shifting)
    edge_dict.update(edge_activities_dict)
    return edge_dict_to_igraph(edge_dict, name)
    


def edge_dict_to_supernetwork(edge_dict, name):
    # using the concatenation of the two edge_dict 
    # generated by txt_to_superedge_dict() and txt_to_activities_edge_dict()
    # construct a super nnetwork with igraph
    g = Graph(edges=edge_dict.keys(), directed=True)
    g["name"] = name


def txt_to_superedge_dict(filepath, alpha=1.0):
    # Contruct super edge data from *_net_times.txt files
    # alpha is a coefficient to translate travel times to travel costs
    # see networks/SmallGrid_net_times.txt for example
    header_passed = False
    edge_dict = {}
    with open(filepath) as f:
        for line in f.readlines():
            if header_passed == True:
                line = line.split()
                if len(line) == 0: break
                line[-1] = line[-1][:-1]
                s = int(line[0])
                t = int(line[1])
                for i in range(num_steps):
                    edge_dict[(s+i*num_nodes, t+i*num_nodes)] = {'weight': alpha*float(line[i+2]),
                                                                'type': -1}
            else:
                if line[0] == '~': header_passed = True
                if line[:17] == '<NUMBER OF NODES>': num_nodes = int(line[17:])
                if line[:17] == '<NUMBER OF STEPS>': num_steps = int(line[17:])
    return edge_dict


def txt_to_activities_edge_dict(filepath, shifting=True):
    # Add activity edges to edge_dict generated from txt_to_superedge_dict()
    # filepath contains list of activities from *_activities.txt
    # see networks/SmallGrid_activities.txt for example
    # activity weights are < 0 because equal to minus reward
    # if shifting is True, the activity weights are shifted by 
    # (end-start+1)*shift to make activity edges positive
    header_passed = False
    edge_dict = {}
    tmp = []
    shift = 0.0
    with open(filepath) as f:
        for line in f.readlines():
            if header_passed == True:
                line = line.split()
                if len(line) == 0: break
                line[-1] = line[-1][:-1]
                node = int(line[0])
                start = int(line[1]) - start_time
                end = int(line[2]) - start_time
                type_edge = int(line[3])
                reward = float(line[4])
                # note that we take start-1 since being on vertex v slice t
                # means only starting the activity at v at slice t+1
                duration = 1+end-start
                if shifting and shift < reward/duration: 
                    shift = np.ceil(reward/duration)
                edge = (node + (start-1)*num_nodes, node + end*num_nodes)
                tmp.append([edge, type_edge, reward, duration])
            else:
                if line[0] == '~': header_passed = True
                if line[:17] == '<NUMBER OF NODES>': num_nodes = int(line[17:])
                if line[:12] == '<START TIME>': start_time = int(line[12:])
                if line[:15] == '<HOME LOCATION>': home = int(line[15:])
                if line[:17] == '<NUMBER OF STEPS>': num_steps = int(line[17:])
        for edge, type_edge, reward, duration in tmp:
            edge_dict[edge] = {'weight': -reward + duration*shift, 'type': type_edge}
        for i in range(num_steps-1):
            edge = (home+i*num_nodes, home+(i+1)*num_nodes)
            edge_dict[edge] = {'weight': shift, 'type': -1}
    return edge_dict

